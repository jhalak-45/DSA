<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Visualization using Prim's Algorithm</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin-top: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .form-group {
            margin: 10px 0;
        }

        /* .canvas-container {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        } */

        .canvas-container canvas {
            border: 1px solid black;
            /* margin: 10px; */
        }

        .hint {
            font-size: 0.9em;
            color: gray;
        }

        .info {
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <div class="container-fluid px-3">
        <h1 class="text-center my-4 px-2">Graph Visualization using Prim's Algorithm</h1>
        <div class="form-group">
            <label for="vertexCount">Number of vertices:</label>
            <input type="number" class="form-control" id="vertexCount" min="2" max="10" required>
            <small class="form-text text-muted">Enter a number between 2 and 10.</small>
            <button class="btn btn-primary mt-2" onclick="createVerticesInput()">Create Vertices Input</button>
        </div>
        <div id="verticesInput" class="form-group row"></div>
        <div class="row">
            <div class="form-group col-md-8">
                <label for="edgeStart">Edge Start:</label>
                <input type="text" class="form-control" id="edgeStart" placeholder="Enter the name of the starting vertex." required>
                <label for="edgeEnd">Edge End:</label>
                <input type="text" class="form-control" id="edgeEnd" placeholder="Enter the name of the ending vertex." required>
                <label for="edgeWeight">Edge Weight:</label>
                <input type="number" class="form-control" id="edgeWeight" placeholder="Enter a positive number for the edge weight." required>
                <button class="btn btn-secondary mt-2" onclick="addEdge()">Add Edge</button>
            </div>
            <div class="col-md-4 py-4 mt-1">
                <button class="btn btn-info my-2" data-toggle="modal" data-target="#aboutModal">About Prim's Algorithm</button>
                <button class="btn btn-success my-2" onclick="primAlgorithm()">Run Prim's Algorithm</button>
                <button class="btn btn-warning my-2" onclick="downloadGraph()">Download Graph</button>
               
            </div>
        </div>
         <div class="canvas-container container-fluid px-0 m-0 row px-2">
            <canvas id="graphCanvas" class="col-md-6" width="550" height="550"></canvas>
            <canvas id="mstCanvas"class="col-md-6"  width="550" height="550"></canvas>
        </div>
        <div class="info">
            <p id="totalWeight">Total Weight of Graph: 0</p>
            <p id="mstWeight">Total Weight after Spanning: 0</p>
        </div>
    </div>

    <!-- About Modal -->
    <div class="modal fade" id="aboutModal" tabindex="-1" aria-labelledby="aboutModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="aboutModalLabel">About Prim's Algorithm</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p>Prim's Algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted
                        undirected graph. This means it finds a subset of the edges that forms a tree that includes
                        every vertex, where the total weight of all the edges in the tree is minimized.</p>
                    <p>The algorithm operates by building the MST one vertex at a time, from an arbitrary starting
                        vertex, at each step adding the cheapest possible connection from the tree to another vertex.
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const mstCanvas = document.getElementById('mstCanvas');
        const mstCtx = mstCanvas.getContext('2d');

        let vertices = [];
        let edges = [];

        function createVerticesInput() {
            const vertexCount = document.getElementById('vertexCount').value;
            const verticesInputDiv = document.getElementById('verticesInput');
            verticesInputDiv.innerHTML = '';

            for (let i = 0; i < vertexCount; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'vertex' + i;
                input.className = 'form-control my-2';
                input.placeholder = 'Vertex ' + (i + 1) + ' name';
                input.required = true;
                verticesInputDiv.appendChild(input);
            }

            const button = document.createElement('button');
            button.textContent = 'Create Vertices';
            button.className = 'btn btn-primary mt-2';
            button.onclick = createVertices;
            verticesInputDiv.appendChild(button);
        }

        function createVertices() {
            const vertexCount = document.getElementById('vertexCount').value;
            vertices = [];

            for (let i = 0; i < vertexCount; i++) {
                const name = document.getElementById('vertex' + i).value || 'Vertex ' + i;
                vertices.push({ name: name, x: Math.random() * graphCanvas.width, y: Math.random() * graphCanvas.height });
            }

            drawGraph(graphCtx, vertices, edges);
            updateTotalWeight();
        }

        function addEdge() {
            const startName = document.getElementById('edgeStart').value;
            const endName = document.getElementById('edgeEnd').value;
            const weight = document.getElementById('edgeWeight').value;

            const start = vertices.findIndex(vertex => vertex.name === startName);
            const end = vertices.findIndex(vertex => vertex.name === endName);

            if (start !== -1 && end !== -1 && start !== end) {
                edges.push({ start: start, end: end, weight: parseInt(weight) });
                drawGraph(graphCtx, vertices, edges);
                updateTotalWeight();
            } else {
                alert('Invalid edge input.');
            }
        }

        function drawGraph(ctx, vertices, edges) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Draw edges
            edges.forEach(edge => {
                const start = vertices[edge.start];
                const end = vertices[edge.end];
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
                ctx.closePath();

                // Draw weight
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                ctx.fillText(edge.weight, midX, midY);
            });

            // Draw vertices
            vertices.forEach((vertex, index) => {
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'green';
                ctx.fill();
                ctx.closePath();

                // Draw vertex name
                ctx.fillStyle = 'black';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(vertex.name, vertex.x - 15, vertex.y - 20);
            });
        }

        function primAlgorithm() {
            const vertexCount = vertices.length;
            const inTree = new Array(vertexCount).fill(false);
            const dist = new Array(vertexCount).fill(Infinity);
            const parent = new Array(vertexCount).fill(null);

            dist[0] = 0;

            for (let i = 0; i < vertexCount - 1; i++) {
                let u = minDistance(dist, inTree);
                inTree[u] = true;

                edges.forEach(edge => {
                    const { start, end, weight } = edge;
                    if (start === u && !inTree[end] && weight < dist[end]) {
                        dist[end] = weight;


                        parent[end] = u;
                    } else if (end === u && !inTree[start] && weight < dist[start]) {
                        dist[start] = weight;
                        parent[start] = u;
                    }
                });
            }

            drawMST(parent);
            updateMSTWeight();
            updateTotalWeight();
        }

        function minDistance(dist, inTree) {
            let min = Infinity;
            let minIndex = -1;

            dist.forEach((value, index) => {
                if (!inTree[index] && value < min) {
                    min = value;
                    minIndex = index;
                }
            });

            return minIndex;
        }

        function drawMST(parent) {
            mstCtx.clearRect(0, 0, mstCtx.canvas.width, mstCtx.canvas.height);
            drawGraph(mstCtx, vertices, edges);

            mstCtx.strokeStyle = 'red';
            parent.forEach((parentNode, index) => {
                if (parentNode !== null) {
                    const start = vertices[parentNode];
                    const end = vertices[index];
                    mstCtx.beginPath();
                    mstCtx.moveTo(start.x, start.y);
                    mstCtx.lineTo(end.x, end.y);
                    mstCtx.stroke();
                    mstCtx.closePath();
                }
            });
        }

        function updateTotalWeight() {
            const totalWeight = edges.reduce((sum, edge) => sum + edge.weight, 0);
            document.getElementById('totalWeight').textContent = `Total Weight of Graph: ${totalWeight}`;
        }

        function updateMSTWeight() {
            const vertexCount = vertices.length;
            const mstEdges = [];
            const inTree = new Array(vertexCount).fill(false);
            const parent = new Array(vertexCount).fill(null);
            const dist = new Array(vertexCount).fill(Infinity);

            dist[0] = 0;

            for (let i = 0; i < vertexCount - 1; i++) {
                let u = minDistance(dist, inTree);
                inTree[u] = true;

                edges.forEach(edge => {
                    const { start, end, weight } = edge;
                    if (start === u && !inTree[end] && weight < dist[end]) {
                        dist[end] = weight;
                        parent[end] = u;
                    } else if (end === u && !inTree[start] && weight < dist[start]) {
                        dist[start] = weight;
                        parent[start] = u;
                    }
                });
            }

            parent.forEach((parentNode, index) => {
                if (parentNode !== null) {
                    mstEdges.push({ start: parentNode, end: index, weight: edges.find(edge => (edge.start === parentNode && edge.end === index) || (edge.start === index && edge.end === parentNode)).weight });
                }
            });

            const mstWeight = mstEdges.reduce((sum, edge) => sum + edge.weight, 0);
            document.getElementById('mstWeight').textContent = `Total Weight after Spanning: ${mstWeight}`;
        }

        function downloadGraph() {
            const downloadCanvas = document.createElement('canvas');
            downloadCanvas.width = graphCanvas.width;
            downloadCanvas.height = graphCanvas.height;
            const downloadCtx = downloadCanvas.getContext('2d');

            // Draw a white background
            downloadCtx.fillStyle = 'white';
            downloadCtx.fillRect(0, 0, downloadCanvas.width, downloadCanvas.height);

            // Draw the graph on the white background
            drawGraph(downloadCtx, vertices, edges);

            // Create a link and download the image
            const link = document.createElement('a');
            link.href = downloadCanvas.toDataURL('image/png');
            link.download = 'graph.png';
            link.click();
        }
    </script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>

</html>